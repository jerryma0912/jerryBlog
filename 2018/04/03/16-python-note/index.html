<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="python," />










<meta name="description" content="我在学习完C++后开始学习的python，因此本文主要记录了在学习python时的笔记，以及python语法与c++的一些区别。">
<meta name="keywords" content="python">
<meta property="og:type" content="article">
<meta property="og:title" content="python学习笔记">
<meta property="og:url" content="http://yoursite.com/2018/04/03/16-python-note/index.html">
<meta property="og:site_name" content="JERRY HOME">
<meta property="og:description" content="我在学习完C++后开始学习的python，因此本文主要记录了在学习python时的笔记，以及python语法与c++的一些区别。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-04-10T13:07:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python学习笔记">
<meta name="twitter:description" content="我在学习完C++后开始学习的python，因此本文主要记录了在学习python时的笔记，以及python语法与c++的一些区别。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/04/03/16-python-note/"/>





  <title>python学习笔记 | JERRY HOME</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JERRY HOME</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/03/16-python-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JERRY HOME">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">python学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-03T19:59:43+08:00">
                2018-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">python学习笔记</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python学习笔记/4-学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">4.学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>我在学习完C++后开始学习的python，因此本文主要记录了在学习python时的笔记，以及python语法与c++的一些区别。<br><a id="more"></a></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol>
<li>字符串可以用<code>&#39;&#39;</code>或者<code>&quot;&quot;</code>引起来，当使用<code>三个</code>单引号/双引号时，字符串可以换行。</li>
<li><code>r&#39;&#39;</code>表示’’内部的字符串默认不转义.</li>
<li>None表示空值</li>
<li>and表示&amp;&amp; ，or表示|| , not 表示！</li>
<li>变量可以是任何数据类型，使用时不需要先声明。<code>=</code>可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。<b>这种变量本身类型不固定的语言称之为动态语言<b></b></b></li>
<li>在Python中，通常用全部大写的变量名表示常量，如<code>PI = 3.14159265359</code>。但事实上它仍然是一个变量，Python根本没有任何机制保证其不会被改变。</li>
<li><code>/</code>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数。<code>//</code>称为地板除，是两个整数的除法仍然是整数。</li>
<li>python中，字符串是以Unicode编码的，<code>b&#39;abc&#39;</code>表示bytes类型的数据，<code>ord(str)</code>将获取字符的整数表示，<code>char(num)</code>把编码转换为对应的字符.<code>字符串.encode(&#39;类型&#39;)</code>用于编码，<code>字符串.decode(&#39;类型&#39;)</code>用于解码</li>
<li>字符格式化：%d 整数 %f 浮点数 %s 字符串 %x 十六进制整数，还可以指定是否补0和整数与小数的位数：<code>print(&#39;%2d-%05d&#39; % (3, 1))</code>-&gt;<code>3-00001</code>,<code>print(&#39;%.2f&#39; % 3.1415926)</code>-&gt;<code>3.14</code>,</li>
<li><code>%%</code>为转义<code>%</code></li>
<li>使用format也可以格式化。<code>&#39;Hello, {0}, 成绩提升了 {1:.1f}%&#39;.format(&#39;小明&#39;, 17.125)</code></li>
<li>set是一组没有重复key的集合，不存储value，不可以放入可变对象。要创建一个set，需要提供一个list作为输入集合.通过<code>add(key)</code>添加元素，<code>remove(key)</code>删除元素。<code>s1 &amp; s2</code>做交集，<code>s1 | s2</code>做并集</li>
<li><p>对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &apos;abc&apos;</span><br><span class="line">&gt;&gt;&gt; b = a.replace(&apos;a&apos;, &apos;A&apos;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&apos;Abc&apos;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&apos;abc&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>[l.lower() for l in L1 if isinstance(l ,str)]</code>  <code>[m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]</code>列表生成式。前面写要生成的元素，后面写条件，中的的循环可以有多个。</p>
</li>
<li>生成器的两种方法：(1)按列表生成式的方法，把中括号换为小括号。(2)函数中使用<code>yield</code>,此时要注意，函数在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。此外，但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">g = fib(6)</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        x = next(g)</span><br><span class="line">        print(&apos;g:&apos;, x)</span><br><span class="line">    except StopIteration as e:</span><br><span class="line">        print(&apos;Generator return value:&apos;, e.value)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><ol>
<li><p>if语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if &lt;条件判断1&gt;:</span><br><span class="line">    &lt;执行1&gt;</span><br><span class="line">elif &lt;条件判断2&gt;:</span><br><span class="line">    &lt;执行2&gt;</span><br><span class="line">elif &lt;条件判断3&gt;:</span><br><span class="line">    &lt;执行3&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;执行4&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环语句(只有for语句和while语句)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1) for x in ...:</span><br><span class="line">(2) while ...:</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认情况下，dict迭代的是key。如果要迭代value，可以用<code>for value in d.values()</code>，如果要同时迭代key和value，可以用<code>for k, v in d.items()</code>。</p>
</li>
<li><p>可以通过collections模块的Iterable类型判断对象是否可迭代（是否是可迭代对象）：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterable</span><br><span class="line">isinstance(&apos;abc&apos;, Iterable) # str是否可迭代</span><br></pre></td></tr></table></figure>
<p>可以使用isinstance()判断一个对象是否是Iterator(迭代器)对象（可以被next()函数调用并不断返回下一个值的对象）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterator</span><br><span class="line">isinstance((x for x in range(10)), Iterator)</span><br></pre></td></tr></table></figure>
<p>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。把list、dict、str等Iterable变成Iterator可以使用iter()函数</p>
</li>
<li>可以内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):</span><br><span class="line">    print(i, value)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol>
<li>函数名其实就是指向一个函数对象的引用，即函数名是一个变量！完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”。<code>f=abs</code>。也可以<code>abs=10</code>,注意，由于abs函数实际上是定义在<code>import builtins</code>模块中的，所以要让修改abs变量的指向在其它模块也生效，要用<code>import builtins; builtins.abs = 10</code>。</li>
<li><p>如果想定义一个什么事也不做的空函数，可以用pass语句：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def nop():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据类型检查可以用内置函数isinstance()实现：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if not isinstance(x, (int, float)):</span><br><span class="line">        raise TypeError(&apos;bad operand type&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以返回多个值！但事实上，返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)</span><br><span class="line">&gt;&gt;&gt; print(x, y)</span><br><span class="line">151.96152422706632 70.0</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>def power(x, n=2):</code>：默认参数，<b>!!默认参数必须指向不变对象!!</b>调用时如果不按顺序提供部分默认参数时，需要把参数名写上。<br><code>def calc(*numbers):</code>:可变参数，此时，参数numbers接收到的是一个tuple。如果实参为list或tuple，可以在list或tuple实参前加<code>*</code>,把它变为可变参数传进去。<br><code>def person(name, age, **kw):</code>: 关键字参数，允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。可以扩展函数的功能。<br><code>def person(name, age, *, city, job):</code>:命名关键字参数，用<em>分隔，调用方式同上，但此时被限制了关键字参数的名字。命名关键字参数可以有缺省值。如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符</em>了：<code>def person(name, age, *args, city, job):</code><br><b>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</b></p>
</li>
<li>解决递归调用栈溢出的方法是通过尾递归优化，尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</li>
<li>一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</li>
<li>map()函数接收两个参数，一个是<code>函数</code>，一个是<code>Iterable</code>，map将传入的函数依次作用到序列的每个元素，并把结果作为<code>新的Iterator</code>返回</li>
<li>reduce把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：<code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code>,要导入包<code>from functools import reduce</code></li>
<li>filter()接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</li>
<li>sorted()函数也是一个高阶函数，它可以接收一个key函数来实现自定义的排序,可以接收reverse=True进行反向排序.<code>sorted([36, 5, -12, 9, -21], key=abs,reverse=True)</code></li>
<li>函数可以作为返回值</li>
<li>内部函数可以引用外部函数的参数和局部变量，当外部函回函数内部函数时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。返回闭包时牢记一点：<b>返回函数不要引用任何循环变量，或者后续会发生变化的变量。</b></li>
<li>关键字lambda表示匿名函数，冒号前面的x表示函数参数。匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</li>
<li>函数对象有一个<strong>name</strong>属性，可以拿到函数的名字</li>
<li><p>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line">def log(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">      print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">      return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">       @functools.wraps(func)</span><br><span class="line">       def wrapper(*args, **kw):</span><br><span class="line">            print(&apos;%s %s():&apos; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">       return wrapper</span><br><span class="line">  return decorator</span><br></pre></td></tr></table></figure>
</li>
<li><p>functools.partial可以帮助我们创建偏函数。<code>int2 = functools.partial(int, base=2)</code>，<code>max2 = functools.partial(max, 10)</code></p>
</li>
</ol>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ol>
<li>每一个包目录下面都会有一个<strong>init</strong>.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<strong>init</strong>.py可以是空文件，也可以有Python代码，因为<strong>init</strong>.py本身就是一个模块，而它的模块名就是mycompany。</li>
<li>当我们在命令行运行一个模块文件时，Python解释器把一个特殊变量<strong>name</strong>置为<strong>main</strong>，而如果在其他地方导入该模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</li>
<li>正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等。<br>类似<strong>xxx</strong>这样的变量是特殊变量，可以被直接引用，但是有特殊用途。<br>类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用（不是不能！）。</li>
<li><code>import xxx</code> 是从 Python 系统库，或者项目的最外层导入 xxx。<br><code>from . import xxx</code> 是从同一文件夹下导入 xxx。<br><code>from .yyy import xxx</code> 是从当前目录的子文件夹 yyy 中导入 xxx。</li>
<li>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中。</li>
</ol>
<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><ol>
<li>创建类：<code>class Student(object):</code></li>
<li><p>可以自由地给一个实例变量绑定任何类型的属性。<code>bart.name=&#39;jerry&#39;</code>,在<strong>init</strong>中绑定的属性则一定要有。也可以给实例绑定方法<code>s.set_age = MethodType(set_age, s)</code><br>可以使用<code>__slots__</code>变量来限制实例能添加的属性：<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的,除非在子类中也定义<strong>slots</strong>，这样，子类实例允许定义的属性就是自身的<strong>slots</strong>加上父类的<strong>slots</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    __slots__ = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称</span><br></pre></td></tr></table></figure>
</li>
<li><p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p>
</li>
<li>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<strong>，在Python中，实例的变量名如果以</strong>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。因为此时它已经改名为<code>_类名__属性名</code></li>
<li>动态语言的“鸭子类型”决定了它并不要求严格的继承体系。</li>
<li><code>type()</code>可以用来判断对象类型。 <code>type(123)==int   True</code> <code>type(fn)==types.FunctionType   True</code><br><code>isinstance</code>也可用来判断  <code>isinstance([1, 2, 3], (list, tuple))   判断是否是其中一种</code><br><code>dir()</code>可以获得一个对象的所有属性和方法。</li>
<li>我们自己写的类，如果也想用len(myObj)的话，就自己写一个<strong>len</strong>()方法；<br>getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态。</li>
<li><p>可以直接在class中定义属性，这种属性是类属性，归Student类所有。相同名称的实例属性将屏蔽掉类属性，但是当你<code>删除实例属性</code>后，再使用相同的名称，访问到的将是类属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    name = &apos;Student&apos;</span><br></pre></td></tr></table></figure>
<p>类方法内调用时，可以使用<code>类名.变量名</code>调用。</p>
</li>
<li><p>Python内置的@property装饰器就是负责把一个方法变成属性调用的。<br>把一个getter方法变成属性，只需要加上<code>@property</code>，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个setter方法变成属性赋值</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">@property</span><br><span class="line">def score(self):</span><br><span class="line">    return self._score</span><br><span class="line"></span><br><span class="line">@score.setter</span><br><span class="line">def score(self, value):</span><br><span class="line">    if not isinstance(value, int):</span><br><span class="line">        raise ValueError(&apos;score must be an integer!&apos;)</span><br><span class="line">    if value &lt; 0 or value &gt; 100:</span><br><span class="line">        raise ValueError(&apos;score must between 0 ~ 100!&apos;)</span><br><span class="line">    self._score = value</span><br><span class="line"></span><br><span class="line">#调用时：</span><br><span class="line">s.score</span><br><span class="line">s.score=10</span><br></pre></td></tr></table></figure>
</li>
<li><p>python可以实现多重继承，为了看清关系，建议将除主继承以外的继承的类命名结尾为<code>MixIn</code>。MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p>
</li>
<li><code>__str__()</code>用于print()类对象时，返回用户看到的字符串；<code>__repr__()</code>用于直接调用类对象时，为调试服务的；因此，可以在定义了一个后，直接<code>__repr__ = __str__</code></li>
<li><p>如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个<strong>iter</strong>()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<strong>next</strong>()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">def __init__(self):</span><br><span class="line">    self.a, self.b = 0, 1 # 初始化两个计数器a，b</span><br><span class="line"></span><br><span class="line">def __iter__(self):</span><br><span class="line">    return self # 实例本身就是迭代对象，故返回自己</span><br><span class="line"></span><br><span class="line">def __next__(self):</span><br><span class="line">    self.a, self.b = self.b, self.a + self.b # 计算下一个值</span><br><span class="line">    if self.a &gt; 100000: # 退出循环的条件</span><br><span class="line">        raise StopIteration()</span><br><span class="line">    return self.a # 返回下一个值</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__getitem__</code>可以将类实例表现的像list那样按照下标取出元素。注意！！<code>__getitem__()</code>传入的参数可能是一个int，也可能是一个切片对象slice，所以要做判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">def __getitem__(self, n):</span><br><span class="line">    if isinstance(n, int): # n是索引</span><br><span class="line">        pass</span><br><span class="line">    if isinstance(n, slice): # n是切片</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<p>与之对应的是<code>__setitem__()</code>方法，把对象视作list或dict来对集合赋值。最后，还有一个<code>__delitem__()</code>方法，用于删除某个元素。</p>
</li>
<li><p><code>__getattr__()</code>方法可以动态返回一个属性(此时调用方式为<code>s.age</code>)。也可以返回一个函数(此时调用方式为<code>s.age()</code>)。<br>注意，只有在没有找到属性的情况下，才调用<strong>getattr</strong>，已有的属性不会在<strong>getattr</strong>中查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def __getattr__(self, attr):</span><br><span class="line">    if attr==&apos;score&apos;:</span><br><span class="line">        return 99</span><br></pre></td></tr></table></figure>
<p>如果要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误。</p>
</li>
<li><p><code>__call__()</code>方法，就可以直接对实例进行调用。此外，他也可以定义参数，对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Student(&apos;Michael&apos;)</span><br><span class="line">s() # self参数不要传入</span><br></pre></td></tr></table></figure>
<p>需要判断一个对象是否能被调用时，可以通过<code>callable()</code>函数判断一个对象是否是“可调用”对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callable(Student())</span><br></pre></td></tr></table></figure>
<p>一个经典的定制类的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Chain():</span><br><span class="line">    def __init__(self,path=&apos;&apos;):</span><br><span class="line">        self._path = path</span><br><span class="line">    def __getattr__(self, item):</span><br><span class="line">      return Chain(&apos;%s/%s&apos; % (self._path,item))</span><br><span class="line">  def __str__(self):</span><br><span class="line">     return self._path</span><br><span class="line">  __repr__ = __str__</span><br><span class="line">  __call__ = __getattr__</span><br><span class="line"></span><br><span class="line">print ( Chain().users(&apos;michael&apos;).repos )</span><br><span class="line"></span><br><span class="line">#分析：</span><br><span class="line">Chain()先调用了init；</span><br><span class="line">然后调用getattr，此时相当于生成了一个新的Chain的实例，然后通过call，把实例当成一个函数进行调用；</span><br><span class="line">接着再调用getattr；</span><br><span class="line">最后调用str，输出当前的路径。</span><br><span class="line">------</span><br><span class="line">换句话说，. 就相当于调用 __getattr__，(...) 就相当于调用 __call__。</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义枚举类实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line">Month = Enum(&apos;Month&apos;, (&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;, &apos;May&apos;, &apos;Jun&apos;, &apos;Jul&apos;, &apos;Aug&apos;, &apos;Sep&apos;, &apos;Oct&apos;, &apos;Nov&apos;, &apos;Dec&apos;))</span><br></pre></td></tr></table></figure>
<p>调用枚举类成员<code>Month.Jan</code>，枚举所有成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for name, member in Month.__members__.items():</span><br><span class="line">    print(name, &apos;=&gt;&apos;, member, &apos;,&apos;, member.value)</span><br><span class="line"></span><br><span class="line">#value属性则是自动赋给成员的int常量，默认从1开始计数。</span><br></pre></td></tr></table></figure>
<p>如果需要更精确地控制枚举类型，可以从Enum派生出自定义类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum, unique</span><br><span class="line"></span><br><span class="line">@unique #帮助我们检查保证没有重复值</span><br><span class="line">class Weekday(Enum):</span><br><span class="line">    Sun = 0 # Sun的value被设定为0</span><br><span class="line">    Mon = 1</span><br><span class="line">    Tue = 2</span><br><span class="line">    Wed = 3</span><br><span class="line">    Thu = 4</span><br><span class="line">    Fri = 5</span><br><span class="line">    Sat = 6</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; day1 = Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(day1)</span><br><span class="line">Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(Weekday.Tue)</span><br><span class="line">Weekday.Tue</span><br><span class="line">&gt;&gt;&gt; print(Weekday[&apos;Tue&apos;])</span><br><span class="line">Weekday.Tue</span><br><span class="line">&gt;&gt;&gt; print(Weekday.Tue.value)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; print(day1 == Weekday.Mon)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; print(day1 == Weekday.Tue)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; print(Weekday(1))</span><br><span class="line">Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(day1 == Weekday(1))</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; Weekday(7)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: 7 is not a valid Weekday</span><br><span class="line">&gt;&gt;&gt; for name, member in Weekday.__members__.items():</span><br><span class="line">...     print(name, &apos;=&gt;&apos;, member)</span><br><span class="line">...</span><br><span class="line">Sun =&gt; Weekday.Sun</span><br><span class="line">Mon =&gt; Weekday.Mon</span><br><span class="line">Tue =&gt; Weekday.Tue</span><br><span class="line">Wed =&gt; Weekday.Wed</span><br><span class="line">Thu =&gt; Weekday.Thu</span><br><span class="line">Fri =&gt; Weekday.Fri</span><br><span class="line">Sat =&gt; Weekday.Sat</span><br></pre></td></tr></table></figure>
</li>
<li><p>class的定义是运行时动态创建的，而创建class的方法就是使用type()函数。要创建一个class对象，type()函数依次传入3个参数：<br><code>class的名称</code>；<code>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法</code>；<code>class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def fn(self, name=&apos;world&apos;): # 先定义函数</span><br><span class="line">    print(&apos;Hello, %s.&apos; % name)</span><br><span class="line">Hello = type(&apos;Hello&apos;, (object,), dict(hello=fn)) # 创建Hello class</span><br></pre></td></tr></table></figure>
</li>
<li><p>要控制类的创建行为，还可以使用metaclass（元类）。可以理解为：先定义metaclass，就可以创建类，最后创建实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># metaclass是类的模板，所以必须从`type`类型派生：</span><br><span class="line">class ListMetaclass(type):</span><br><span class="line">    def __new__(cls, name, bases, attrs):</span><br><span class="line">        attrs[&apos;add&apos;] = lambda self, value: self.append(value)</span><br><span class="line">        return type.__new__(cls, name, bases, attrs)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#创建类</span><br><span class="line">class MyList(list, metaclass=ListMetaclass):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>当我们传入关键字参数metaclass时，魔术就生效了，它指示Python解释器在创建MyList时，要通过ListMetaclass.<strong>new</strong>()来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。<strong>new</strong>()方法接收到的参数依次是：<br><code>当前准备创建的类的对象</code>；<code>类的名字</code>；<code>类继承的父类集合</code>；<code>类的方法集合</code>。</p>
</li>
</ol>
<h3 id="错误、调试、测试"><a href="#错误、调试、测试" class="headerlink" title="错误、调试、测试"></a>错误、调试、测试</h3><ol>
<li><p>当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(&apos;try...&apos;)</span><br><span class="line">    r = 10 / int(&apos;2&apos;)</span><br><span class="line">    print(&apos;result:&apos;, r)</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(&apos;ValueError:&apos;, e)</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print(&apos;ZeroDivisionError:&apos;, e)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;no error!&apos;)</span><br><span class="line">finally:</span><br><span class="line">    print(&apos;finally...&apos;)</span><br><span class="line">print(&apos;END&apos;)</span><br></pre></td></tr></table></figure>
<p> Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。<a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" target="_blank" rel="noopener">常见的错误类型和继承关系</a><br> 不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写try…except…finally的麻烦。</p>
</li>
<li><p>Python内置的logging模块可以非常容易地记录错误信息，同时，<code>让程序继续执行下去</code>。通过配置，logging还可以把错误记录到日志文件里，方便事后排查。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">try:</span><br><span class="line">    bar(&apos;0&apos;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    logging.exception(e)</span><br></pre></td></tr></table></figure>
<p> logging允许你指定记录信息的级别，有debug，info，warning，error等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line">s = &apos;0&apos;</span><br><span class="line">n = int(s)</span><br><span class="line">logging.info(&apos;n = %d&apos; % n)</span><br><span class="line">print(10 / n)</span><br></pre></td></tr></table></figure>
</li>
<li><p>用raise语句抛出一个错误的实例。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class FooError(ValueError):</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">def foo(s):</span><br><span class="line">    n = int(s)</span><br><span class="line">    if n==0:</span><br><span class="line">        raise FooError(&apos;invalid value: %s&apos; % s)</span><br><span class="line">    return 10 / n</span><br><span class="line"></span><br><span class="line">foo(&apos;0&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>断言：凡是用print()来辅助查看的地方，都可以用断言（assert）来替代：<code>assert n != 0, &#39;n is zero!&#39;</code>。启动Python解释器时可以用-O参数来关闭assert。</p>
</li>
<li><code>python -m pdb 文件名.py</code>启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。<br> 输入命令<code>l</code>来查看代码。<br> 输入命令<code>n</code>可以单步执行代码<br> 输入命令<code>p 变量名</code>来查看变量<br> 输入命令<code>q</code>结束调试<br> 此外，可以在程序中使用<code>pdb.set_trace()</code>（要导入包<code>import pdb</code>）来使程序会自动在pdb.set_trace()暂停并进入pdb调试环境，<br> 命令<code>p 变量名</code>查看变量<br> 命令<code>c</code>继续运行</li>
<li><p>编写单元测试时，我们需要编写一个测试类，从<code>unittest.TestCase</code>继承。以<code>test</code>开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。<br><code>self.assertEqual(abs(-1), 1)</code>：断言函数返回的结果与1相等<br><code>with self.assertRaises(KeyError):  value = d[&#39;empty&#39;]</code>：访问不存在的key时，断言会抛出KeyError<br>一旦编写好单元测试，我们就可以运行单元测试。最简单的运行方式是在<code>文件名.py</code>的最后加上两行代码。然后直接执行<code>python 文件名.py</code>；另一种方法是在命令行通过参数<code>-m unittest</code>直接运行单元测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>
<p>可以在单元测试中编写两个特殊的setUp()和tearDown()方法。这两个方法会分别在每调用一个测试方法的前后分别被执行。</p>
</li>
<li><p>可以编写文档测试，这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def fact(n):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    Calculate 1*2*...*n</span><br><span class="line">    &gt;&gt;&gt; fact(1)</span><br><span class="line">    1</span><br><span class="line">    &gt;&gt;&gt; fact(10)</span><br><span class="line">    3628800</span><br><span class="line">    &gt;&gt;&gt; fact(-1)</span><br><span class="line">    Traceback (most recent call last):</span><br><span class="line">    ...</span><br><span class="line">    ValueError</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    if n &lt; 1:</span><br><span class="line">        raise ValueError()</span><br><span class="line">    if n == 1:</span><br><span class="line">        return 1</span><br><span class="line">    return n * fact(n - 1)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    import doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure>
<p>注意到最后3行代码。当模块正常导入时，doctest不会被执行。只有在命令行直接运行时，才执行doctest。所以，不必担心doctest会在非测试环境下执行。</p>
</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python/" rel="tag"># python</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/24/15-CountFile/" rel="next" title="使用python统计提交文件并生成报表">
                <i class="fa fa-chevron-left"></i> 使用python统计提交文件并生成报表
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jerry</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语句"><span class="nav-number">2.</span> <span class="nav-text">语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">3.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块"><span class="nav-number">4.</span> <span class="nav-text">模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象编程"><span class="nav-number">5.</span> <span class="nav-text">面向对象编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误、调试、测试"><span class="nav-number">6.</span> <span class="nav-text">错误、调试、测试</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jerry</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info"><a class="theme-link" target="_blank" href="http://www.miitbeian.gov.cn/">浙ICP备17055283号
</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


</body>
</html>
