<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="python," />










<meta name="description" content="我在学习完C++后开始学习的python，因此本文主要记录了在学习python时的笔记，以及python语法与c++的一些区别。">
<meta name="keywords" content="python">
<meta property="og:type" content="article">
<meta property="og:title" content="python学习笔记">
<meta property="og:url" content="http://yoursite.com/2018/04/03/16-python-note/index.html">
<meta property="og:site_name" content="JERRY HOME">
<meta property="og:description" content="我在学习完C++后开始学习的python，因此本文主要记录了在学习python时的笔记，以及python语法与c++的一些区别。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-04-16T13:51:37.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python学习笔记">
<meta name="twitter:description" content="我在学习完C++后开始学习的python，因此本文主要记录了在学习python时的笔记，以及python语法与c++的一些区别。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/04/03/16-python-note/"/>





  <title>python学习笔记 | JERRY HOME</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JERRY HOME</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/03/16-python-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JERRY HOME">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">python学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-03T19:59:43+08:00">
                2018-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">python学习笔记</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python学习笔记/4-学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">4.学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  11.3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  47 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>我在学习完C++后开始学习的python，因此本文主要记录了在学习python时的笔记，以及python语法与c++的一些区别。<br><a id="more"></a></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol>
<li>字符串可以用<code>&#39;&#39;</code>或者<code>&quot;&quot;</code>引起来，当使用<code>三个</code>单引号/双引号时，字符串可以换行。</li>
<li><code>r&#39;&#39;</code>表示’’内部的字符串默认不转义.</li>
<li>None表示空值</li>
<li>and表示&amp;&amp; ，or表示|| , not 表示！</li>
<li>变量可以是任何数据类型，使用时不需要先声明。<code>=</code>可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。<b>这种变量本身类型不固定的语言称之为动态语言<b></b></b></li>
<li>在Python中，通常用全部大写的变量名表示常量，如<code>PI = 3.14159265359</code>。但事实上它仍然是一个变量，Python根本没有任何机制保证其不会被改变。</li>
<li><code>/</code>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数。<code>//</code>称为地板除，是两个整数的除法仍然是整数。</li>
<li>python中，字符串是以Unicode编码的，<code>b&#39;abc&#39;</code>表示bytes类型的数据，<code>ord(str)</code>将获取字符的整数表示，<code>char(num)</code>把编码转换为对应的字符.<code>字符串.encode(&#39;类型&#39;)</code>用于编码，<code>字符串.decode(&#39;类型&#39;)</code>用于解码</li>
<li>字符格式化：%d 整数 %f 浮点数 %s 字符串 %x 十六进制整数，还可以指定是否补0和整数与小数的位数：<code>print(&#39;%2d-%05d&#39; % (3, 1))</code>-&gt;<code>3-00001</code>,<code>print(&#39;%.2f&#39; % 3.1415926)</code>-&gt;<code>3.14</code>,</li>
<li><code>%%</code>为转义<code>%</code></li>
<li>使用format也可以格式化。<code>&#39;Hello, {0}, 成绩提升了 {1:.1f}%&#39;.format(&#39;小明&#39;, 17.125)</code></li>
<li>set是一组没有重复key的集合，不存储value，不可以放入可变对象。要创建一个set，需要提供一个list作为输入集合.通过<code>add(key)</code>添加元素，<code>remove(key)</code>删除元素。<code>s1 &amp; s2</code>做交集，<code>s1 | s2</code>做并集</li>
<li><p>对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &apos;abc&apos;</span><br><span class="line">&gt;&gt;&gt; b = a.replace(&apos;a&apos;, &apos;A&apos;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&apos;Abc&apos;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&apos;abc&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>[l.lower() for l in L1 if isinstance(l ,str)]</code>  <code>[m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]</code>列表生成式。前面写要生成的元素，后面写条件，中的的循环可以有多个。</p>
</li>
<li>生成器的两种方法：(1)按列表生成式的方法，把中括号换为小括号。(2)函数中使用<code>yield</code>,此时要注意，函数在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。此外，但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">g = fib(6)</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        x = next(g)</span><br><span class="line">        print(&apos;g:&apos;, x)</span><br><span class="line">    except StopIteration as e:</span><br><span class="line">        print(&apos;Generator return value:&apos;, e.value)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><ol>
<li><p>if语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if &lt;条件判断1&gt;:</span><br><span class="line">    &lt;执行1&gt;</span><br><span class="line">elif &lt;条件判断2&gt;:</span><br><span class="line">    &lt;执行2&gt;</span><br><span class="line">elif &lt;条件判断3&gt;:</span><br><span class="line">    &lt;执行3&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;执行4&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环语句(只有for语句和while语句)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1) for x in ...:</span><br><span class="line">(2) while ...:</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认情况下，dict迭代的是key。如果要迭代value，可以用<code>for value in d.values()</code>，如果要同时迭代key和value，可以用<code>for k, v in d.items()</code>。</p>
</li>
<li><p>可以通过collections模块的Iterable类型判断对象是否可迭代（是否是可迭代对象）：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterable</span><br><span class="line">isinstance(&apos;abc&apos;, Iterable) # str是否可迭代</span><br></pre></td></tr></table></figure>
<p>可以使用isinstance()判断一个对象是否是Iterator(迭代器)对象（可以被next()函数调用并不断返回下一个值的对象）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterator</span><br><span class="line">isinstance((x for x in range(10)), Iterator)</span><br></pre></td></tr></table></figure>
<p>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。把list、dict、str等Iterable变成Iterator可以使用iter()函数</p>
</li>
<li>可以内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):</span><br><span class="line">    print(i, value)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol>
<li>函数名其实就是指向一个函数对象的引用，即函数名是一个变量！完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”。<code>f=abs</code>。也可以<code>abs=10</code>,注意，由于abs函数实际上是定义在<code>import builtins</code>模块中的，所以要让修改abs变量的指向在其它模块也生效，要用<code>import builtins; builtins.abs = 10</code>。</li>
<li><p>如果想定义一个什么事也不做的空函数，可以用pass语句：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def nop():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据类型检查可以用内置函数isinstance()实现：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if not isinstance(x, (int, float)):</span><br><span class="line">        raise TypeError(&apos;bad operand type&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以返回多个值！但事实上，返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)</span><br><span class="line">&gt;&gt;&gt; print(x, y)</span><br><span class="line">151.96152422706632 70.0</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>def power(x, n=2):</code>：默认参数，<b>!!默认参数必须指向不变对象!!</b>调用时如果不按顺序提供部分默认参数时，需要把参数名写上。<br><code>def calc(*numbers):</code>:可变参数，此时，参数numbers接收到的是一个tuple。如果实参为list或tuple，可以在list或tuple实参前加<code>*</code>,把它变为可变参数传进去。<br><code>def person(name, age, **kw):</code>: 关键字参数，允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。可以扩展函数的功能。<br><code>def person(name, age, *, city, job):</code>:命名关键字参数，用<em>分隔，调用方式同上，但此时被限制了关键字参数的名字。命名关键字参数可以有缺省值。如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符</em>了：<code>def person(name, age, *args, city, job):</code><br><b>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</b></p>
</li>
<li>解决递归调用栈溢出的方法是通过尾递归优化，尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</li>
<li>一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</li>
<li>map()函数接收两个参数，一个是<code>函数</code>，一个是<code>Iterable</code>，map将传入的函数依次作用到序列的每个元素，并把结果作为<code>新的Iterator</code>返回</li>
<li>reduce把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：<code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code>,要导入包<code>from functools import reduce</code></li>
<li>filter()接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</li>
<li>sorted()函数也是一个高阶函数，它可以接收一个key函数来实现自定义的排序,可以接收reverse=True进行反向排序.<code>sorted([36, 5, -12, 9, -21], key=abs,reverse=True)</code></li>
<li>函数可以作为返回值</li>
<li>内部函数可以引用外部函数的参数和局部变量，当外部函回函数内部函数时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。返回闭包时牢记一点：<b>返回函数不要引用任何循环变量，或者后续会发生变化的变量。</b></li>
<li>关键字lambda表示匿名函数，冒号前面的x表示函数参数。匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</li>
<li>函数对象有一个<strong>name</strong>属性，可以拿到函数的名字</li>
<li><p>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line">def log(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">      print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">      return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">       @functools.wraps(func)</span><br><span class="line">       def wrapper(*args, **kw):</span><br><span class="line">            print(&apos;%s %s():&apos; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">       return wrapper</span><br><span class="line">  return decorator</span><br></pre></td></tr></table></figure>
</li>
<li><p>functools.partial可以帮助我们创建偏函数。<code>int2 = functools.partial(int, base=2)</code>，<code>max2 = functools.partial(max, 10)</code></p>
</li>
</ol>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ol>
<li>每一个包目录下面都会有一个<strong>init</strong>.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<strong>init</strong>.py可以是空文件，也可以有Python代码，因为<strong>init</strong>.py本身就是一个模块，而它的模块名就是mycompany。</li>
<li>当我们在命令行运行一个模块文件时，Python解释器把一个特殊变量<strong>name</strong>置为<strong>main</strong>，而如果在其他地方导入该模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</li>
<li>正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等。<br>类似<strong>xxx</strong>这样的变量是特殊变量，可以被直接引用，但是有特殊用途。<br>类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用（不是不能！）。</li>
<li><code>import xxx</code> 是从 Python 系统库，或者项目的最外层导入 xxx。<br><code>from . import xxx</code> 是从同一文件夹下导入 xxx。<br><code>from .yyy import xxx</code> 是从当前目录的子文件夹 yyy 中导入 xxx。<br>此外，<br><code>import Module</code>           #引入模块<br><code>from Module import Other</code> #引入模块中的类、函数或变量<br><code>from Module import *</code>    #引入模块中的所有公开成员</li>
<li>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中。</li>
</ol>
<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><ol>
<li>创建类：<code>class Student(object):</code></li>
<li><p>可以自由地给一个实例变量绑定任何类型的属性。<code>bart.name=&#39;jerry&#39;</code>,在<strong>init</strong>中绑定的属性则一定要有。也可以给实例绑定方法<code>s.set_age = MethodType(set_age, s)</code><br>可以使用<code>__slots__</code>变量来限制实例能添加的属性：<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的,除非在子类中也定义<strong>slots</strong>，这样，子类实例允许定义的属性就是自身的<strong>slots</strong>加上父类的<strong>slots</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    __slots__ = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称</span><br></pre></td></tr></table></figure>
</li>
<li><p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p>
</li>
<li>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<strong>，在Python中，实例的变量名如果以</strong>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。因为此时它已经改名为<code>_类名__属性名</code></li>
<li>动态语言的“鸭子类型”决定了它并不要求严格的继承体系。</li>
<li><code>type()</code>可以用来判断对象类型。 <code>type(123)==int   True</code> <code>type(fn)==types.FunctionType   True</code><br><code>isinstance</code>也可用来判断  <code>isinstance([1, 2, 3], (list, tuple))   判断是否是其中一种</code><br><code>dir()</code>可以获得一个对象的所有属性和方法。</li>
<li>我们自己写的类，如果也想用len(myObj)的话，就自己写一个<strong>len</strong>()方法；<br>getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态。</li>
<li><p>可以直接在class中定义属性，这种属性是类属性，归Student类所有。相同名称的实例属性将屏蔽掉类属性，但是当你<code>删除实例属性</code>后，再使用相同的名称，访问到的将是类属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    name = &apos;Student&apos;</span><br></pre></td></tr></table></figure>
<p>类方法内调用时，可以使用<code>类名.变量名</code>调用。</p>
</li>
<li><p>Python内置的@property装饰器就是负责把一个方法变成属性调用的。<br>把一个getter方法变成属性，只需要加上<code>@property</code>，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个setter方法变成属性赋值</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">@property</span><br><span class="line">def score(self):</span><br><span class="line">    return self._score</span><br><span class="line"></span><br><span class="line">@score.setter</span><br><span class="line">def score(self, value):</span><br><span class="line">    if not isinstance(value, int):</span><br><span class="line">        raise ValueError(&apos;score must be an integer!&apos;)</span><br><span class="line">    if value &lt; 0 or value &gt; 100:</span><br><span class="line">        raise ValueError(&apos;score must between 0 ~ 100!&apos;)</span><br><span class="line">    self._score = value</span><br><span class="line"></span><br><span class="line">#调用时：</span><br><span class="line">s.score</span><br><span class="line">s.score=10</span><br></pre></td></tr></table></figure>
</li>
<li><p>python可以实现多重继承，为了看清关系，建议将除主继承以外的继承的类命名结尾为<code>MixIn</code>。MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p>
</li>
<li><code>__str__()</code>用于print()类对象时，返回用户看到的字符串；<code>__repr__()</code>用于直接调用类对象时，为调试服务的；因此，可以在定义了一个后，直接<code>__repr__ = __str__</code></li>
<li><p>如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个<strong>iter</strong>()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<strong>next</strong>()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">def __init__(self):</span><br><span class="line">    self.a, self.b = 0, 1 # 初始化两个计数器a，b</span><br><span class="line"></span><br><span class="line">def __iter__(self):</span><br><span class="line">    return self # 实例本身就是迭代对象，故返回自己</span><br><span class="line"></span><br><span class="line">def __next__(self):</span><br><span class="line">    self.a, self.b = self.b, self.a + self.b # 计算下一个值</span><br><span class="line">    if self.a &gt; 100000: # 退出循环的条件</span><br><span class="line">        raise StopIteration()</span><br><span class="line">    return self.a # 返回下一个值</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__getitem__</code>可以将类实例表现的像list那样按照下标取出元素。注意！！<code>__getitem__()</code>传入的参数可能是一个int，也可能是一个切片对象slice，所以要做判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">def __getitem__(self, n):</span><br><span class="line">    if isinstance(n, int): # n是索引</span><br><span class="line">        pass</span><br><span class="line">    if isinstance(n, slice): # n是切片</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<p>与之对应的是<code>__setitem__()</code>方法，把对象视作list或dict来对集合赋值。最后，还有一个<code>__delitem__()</code>方法，用于删除某个元素。</p>
</li>
<li><p><code>__getattr__()</code>方法可以动态返回一个属性(此时调用方式为<code>s.age</code>)。也可以返回一个函数(此时调用方式为<code>s.age()</code>)。<br>注意，只有在没有找到属性的情况下，才调用<strong>getattr</strong>，已有的属性不会在<strong>getattr</strong>中查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def __getattr__(self, attr):</span><br><span class="line">    if attr==&apos;score&apos;:</span><br><span class="line">        return 99</span><br></pre></td></tr></table></figure>
<p>如果要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误。</p>
</li>
<li><p><code>__call__()</code>方法，就可以直接对实例进行调用。此外，他也可以定义参数，对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Student(&apos;Michael&apos;)</span><br><span class="line">s() # self参数不要传入</span><br></pre></td></tr></table></figure>
<p>需要判断一个对象是否能被调用时，可以通过<code>callable()</code>函数判断一个对象是否是“可调用”对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callable(Student())</span><br></pre></td></tr></table></figure>
<p>一个经典的定制类的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Chain():</span><br><span class="line">    def __init__(self,path=&apos;&apos;):</span><br><span class="line">        self._path = path</span><br><span class="line">    def __getattr__(self, item):</span><br><span class="line">      return Chain(&apos;%s/%s&apos; % (self._path,item))</span><br><span class="line">  def __str__(self):</span><br><span class="line">     return self._path</span><br><span class="line">  __repr__ = __str__</span><br><span class="line">  __call__ = __getattr__</span><br><span class="line"></span><br><span class="line">print ( Chain().users(&apos;michael&apos;).repos )</span><br><span class="line"></span><br><span class="line">#分析：</span><br><span class="line">Chain()先调用了init；</span><br><span class="line">然后调用getattr，此时相当于生成了一个新的Chain的实例，然后通过call，把实例当成一个函数进行调用；</span><br><span class="line">接着再调用getattr；</span><br><span class="line">最后调用str，输出当前的路径。</span><br><span class="line">------</span><br><span class="line">换句话说，. 就相当于调用 __getattr__，(...) 就相当于调用 __call__。</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义枚举类实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line">Month = Enum(&apos;Month&apos;, (&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;, &apos;May&apos;, &apos;Jun&apos;, &apos;Jul&apos;, &apos;Aug&apos;, &apos;Sep&apos;, &apos;Oct&apos;, &apos;Nov&apos;, &apos;Dec&apos;))</span><br></pre></td></tr></table></figure>
<p>调用枚举类成员<code>Month.Jan</code>，枚举所有成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for name, member in Month.__members__.items():</span><br><span class="line">    print(name, &apos;=&gt;&apos;, member, &apos;,&apos;, member.value)</span><br><span class="line"></span><br><span class="line">#value属性则是自动赋给成员的int常量，默认从1开始计数。</span><br></pre></td></tr></table></figure>
<p>如果需要更精确地控制枚举类型，可以从Enum派生出自定义类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum, unique</span><br><span class="line"></span><br><span class="line">@unique #帮助我们检查保证没有重复值</span><br><span class="line">class Weekday(Enum):</span><br><span class="line">    Sun = 0 # Sun的value被设定为0</span><br><span class="line">    Mon = 1</span><br><span class="line">    Tue = 2</span><br><span class="line">    Wed = 3</span><br><span class="line">    Thu = 4</span><br><span class="line">    Fri = 5</span><br><span class="line">    Sat = 6</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; day1 = Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(day1)</span><br><span class="line">Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(Weekday.Tue)</span><br><span class="line">Weekday.Tue</span><br><span class="line">&gt;&gt;&gt; print(Weekday[&apos;Tue&apos;])</span><br><span class="line">Weekday.Tue</span><br><span class="line">&gt;&gt;&gt; print(Weekday.Tue.value)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; print(day1 == Weekday.Mon)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; print(day1 == Weekday.Tue)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; print(Weekday(1))</span><br><span class="line">Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(day1 == Weekday(1))</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; Weekday(7)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: 7 is not a valid Weekday</span><br><span class="line">&gt;&gt;&gt; for name, member in Weekday.__members__.items():</span><br><span class="line">...     print(name, &apos;=&gt;&apos;, member)</span><br><span class="line">...</span><br><span class="line">Sun =&gt; Weekday.Sun</span><br><span class="line">Mon =&gt; Weekday.Mon</span><br><span class="line">Tue =&gt; Weekday.Tue</span><br><span class="line">Wed =&gt; Weekday.Wed</span><br><span class="line">Thu =&gt; Weekday.Thu</span><br><span class="line">Fri =&gt; Weekday.Fri</span><br><span class="line">Sat =&gt; Weekday.Sat</span><br></pre></td></tr></table></figure>
</li>
<li><p>class的定义是运行时动态创建的，而创建class的方法就是使用type()函数。要创建一个class对象，type()函数依次传入3个参数：<br><code>class的名称</code>；<code>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法</code>；<code>class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def fn(self, name=&apos;world&apos;): # 先定义函数</span><br><span class="line">    print(&apos;Hello, %s.&apos; % name)</span><br><span class="line">Hello = type(&apos;Hello&apos;, (object,), dict(hello=fn)) # 创建Hello class</span><br></pre></td></tr></table></figure>
</li>
<li><p>要控制类的创建行为，还可以使用metaclass（元类）。可以理解为：先定义metaclass，就可以创建类，最后创建实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># metaclass是类的模板，所以必须从`type`类型派生：</span><br><span class="line">class ListMetaclass(type):</span><br><span class="line">    def __new__(cls, name, bases, attrs):</span><br><span class="line">        attrs[&apos;add&apos;] = lambda self, value: self.append(value)</span><br><span class="line">        return type.__new__(cls, name, bases, attrs)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#创建类</span><br><span class="line">class MyList(list, metaclass=ListMetaclass):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>当我们传入关键字参数metaclass时，魔术就生效了，它指示Python解释器在创建MyList时，要通过ListMetaclass.<strong>new</strong>()来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。<strong>new</strong>()方法接收到的参数依次是：<br><code>当前准备创建的类的对象</code>；<code>类的名字</code>；<code>类继承的父类集合</code>；<code>类的方法集合</code>。</p>
</li>
</ol>
<h3 id="错误、调试、测试"><a href="#错误、调试、测试" class="headerlink" title="错误、调试、测试"></a>错误、调试、测试</h3><ol>
<li><p>当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(&apos;try...&apos;)</span><br><span class="line">    r = 10 / int(&apos;2&apos;)</span><br><span class="line">    print(&apos;result:&apos;, r)</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(&apos;ValueError:&apos;, e)</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print(&apos;ZeroDivisionError:&apos;, e)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;no error!&apos;)</span><br><span class="line">finally:</span><br><span class="line">    print(&apos;finally...&apos;)</span><br><span class="line">print(&apos;END&apos;)</span><br></pre></td></tr></table></figure>
<p> Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。<a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" target="_blank" rel="noopener">常见的错误类型和继承关系</a><br> 不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写try…except…finally的麻烦。</p>
</li>
<li><p>Python内置的logging模块可以非常容易地记录错误信息，同时，<code>让程序继续执行下去</code>。通过配置，logging还可以把错误记录到日志文件里，方便事后排查。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">try:</span><br><span class="line">    bar(&apos;0&apos;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    logging.exception(e)</span><br></pre></td></tr></table></figure>
<p> logging允许你指定记录信息的级别，有debug，info，warning，error等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line">s = &apos;0&apos;</span><br><span class="line">n = int(s)</span><br><span class="line">logging.info(&apos;n = %d&apos; % n)</span><br><span class="line">print(10 / n)</span><br></pre></td></tr></table></figure>
</li>
<li><p>用raise语句抛出一个错误的实例。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class FooError(ValueError):</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">def foo(s):</span><br><span class="line">    n = int(s)</span><br><span class="line">    if n==0:</span><br><span class="line">        raise FooError(&apos;invalid value: %s&apos; % s)</span><br><span class="line">    return 10 / n</span><br><span class="line"></span><br><span class="line">foo(&apos;0&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>断言：凡是用print()来辅助查看的地方，都可以用断言（assert）来替代：<code>assert n != 0, &#39;n is zero!&#39;</code>。启动Python解释器时可以用-O参数来关闭assert。</p>
</li>
<li><code>python -m pdb 文件名.py</code>启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。<br> 输入命令<code>l</code>来查看代码。<br> 输入命令<code>n</code>可以单步执行代码<br> 输入命令<code>p 变量名</code>来查看变量<br> 输入命令<code>q</code>结束调试<br> 此外，可以在程序中使用<code>pdb.set_trace()</code>（要导入包<code>import pdb</code>）来使程序会自动在pdb.set_trace()暂停并进入pdb调试环境，<br> 命令<code>p 变量名</code>查看变量<br> 命令<code>c</code>继续运行</li>
<li><p>编写单元测试时，我们需要编写一个测试类，从<code>unittest.TestCase</code>继承。以<code>test</code>开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。<br><code>self.assertEqual(abs(-1), 1)</code>：断言函数返回的结果与1相等<br><code>with self.assertRaises(KeyError):  value = d[&#39;empty&#39;]</code>：访问不存在的key时，断言会抛出KeyError<br>一旦编写好单元测试，我们就可以运行单元测试。最简单的运行方式是在<code>文件名.py</code>的最后加上两行代码。然后直接执行<code>python 文件名.py</code>；另一种方法是在命令行通过参数<code>-m unittest</code>直接运行单元测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>
<p>可以在单元测试中编写两个特殊的setUp()和tearDown()方法。这两个方法会分别在每调用一个测试方法的前后分别被执行。</p>
</li>
<li><p>可以编写文档测试，这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def fact(n):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    Calculate 1*2*...*n</span><br><span class="line">    &gt;&gt;&gt; fact(1)</span><br><span class="line">    1</span><br><span class="line">    &gt;&gt;&gt; fact(10)</span><br><span class="line">    3628800</span><br><span class="line">    &gt;&gt;&gt; fact(-1)</span><br><span class="line">    Traceback (most recent call last):</span><br><span class="line">    ...</span><br><span class="line">    ValueError</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    if n &lt; 1:</span><br><span class="line">        raise ValueError()</span><br><span class="line">    if n == 1:</span><br><span class="line">        return 1</span><br><span class="line">    return n * fact(n - 1)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    import doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure>
<p>注意到最后3行代码。当模块正常导入时，doctest不会被执行。只有在命令行直接运行时，才执行doctest。所以，不必担心doctest会在非测试环境下执行。</p>
</li>
</ol>
<h3 id="IO处理"><a href="#IO处理" class="headerlink" title="IO处理"></a>IO处理</h3><ol>
<li><p><code>f = open(&#39;/Users/michael/test.txt&#39;, &#39;r&#39;,【encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;】)</code>打开文件，如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在。<br>其中，<code>r</code>表示读，<code>rb</code>表示按二进制读。encoding参数表示编码类型，errors参数表示如果遇到编码错误后如何处理。最简单的方式是直接忽略<br><code>w</code>表示写，<code>wb</code>表示按二进制写,如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）<br><code>a</code>以追加模式写入。<br><code>f.read()</code>可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示；<code>read(size)</code>方法，每次最多读取size个字节的内容。<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回list<br><code>f.write(&#39;Hello, world!&#39;)</code>，通过反复调用write()来写入文件。<br><code>f.close()</code>关闭文件。<br>可以使用with语句简化书写。（只能在<code>支持了上下文管理器的对象</code>使用，会自动调用close语句）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;/path/to/file&apos;, &apos;r&apos;) as f:</span><br><span class="line">    for line in f.readlines():</span><br><span class="line">        print(line.strip()) # 把末尾的&apos;\n&apos;删掉</span><br></pre></td></tr></table></figure>
</li>
<li><p>要把str写入StringIO，我们需要先创建一个StringIO，然后，<code>f.write(&#39;hello&#39;)</code>像文件一样写入即可。使用<code>f.getvalue()</code>获得写入后的str.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from io import StringIO</span><br><span class="line">f = StringIO()</span><br><span class="line">f.write(&apos;world!&apos;)</span><br><span class="line">f.getvalue()</span><br></pre></td></tr></table></figure>
<p>如果要操作二进制数据，就需要使用BytesIO.函数与StringIO相同。</p>
</li>
<li><p>os模块下的基本功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">os.name #操作系统类型</span><br><span class="line">os.uname()   #详细的系统信息（windows没有）</span><br><span class="line">os.environ  #环境变量</span><br><span class="line">os.environ.get(&apos;key&apos;)  #获取某个环境变量的值</span><br><span class="line">os.path.abspath(&apos;.&apos;) #查看当前目录的绝对路径</span><br><span class="line">os.mkdir(&apos;/Users/michael/testdir&apos;)  #创建一个目录</span><br><span class="line">os.rmdir(&apos;/Users/michael/testdir&apos;)   # 删掉一个目录</span><br><span class="line">os.path.join(&apos;/Users/michael&apos;, &apos;testdir&apos;)  #把两个路径合成一个时，要通过该函数,不要求目录和文件要真实存在</span><br><span class="line">os.path.split(&apos;/Users/michael/testdir/file.txt&apos;)  #拆分路径,不要求目录和文件要真实存在</span><br><span class="line">os.path.splitext(&apos;/path/to/file.txt&apos;) #直接让你得到文件扩展名,不要求目录和文件要真实存在</span><br><span class="line">os.rename(&apos;test.txt&apos;, &apos;test.py&apos;) # 对文件重命名</span><br><span class="line">os.remove(&apos;test.py&apos;) # 删掉文件</span><br></pre></td></tr></table></figure>
<p>shutil模块可以作为os模块的补充：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copyfile()  #复制文件</span><br></pre></td></tr></table></figure>
<p>我们可以利用Python的特性来过滤文件，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[x for x in os.listdir(&apos;.&apos;) if os.path.isdir(x)]  #列出当前目录下的所有目录</span><br><span class="line">[x for x in os.listdir(&apos;.&apos;) if os.path.isfile(x) and os.path.splitext(x)[1]==&apos;.py&apos;]  #列出所有的.py文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量从内存中变成可存储或传输的过程称之为序列化.在Python中叫pickling.反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。Python提供了<code>pickle模块</code>来实现序列化。<br><code>pickle.dumps()</code>方法把任意对象序列化成一个bytes;<br><code>pickle.dump()</code>直接把对象序列化后写入一个file-like Object;<br><code>pickle.loads()</code>方法反序列化出对象;<br><code>pickle.load()</code>方法从一个file-like Object中直接反序列化出对象.<br>注意：Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p>
</li>
<li><p>Python内置的<code>json模块</code>提供了非常完善的Python对象到JSON格式的转换。函数与上述相同。<br>如果需要定制JSON序列化，则传参时，<code>default</code>参数填写对应的转换函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def student2dict(std):</span><br><span class="line">     return &#123;</span><br><span class="line">         &apos;name&apos;: std.name,</span><br><span class="line">         &apos;age&apos;: std.age,</span><br><span class="line">         &apos;score&apos;: std.score</span><br><span class="line">     &#125;</span><br><span class="line">json.dumps(s, default=student2dict)</span><br></pre></td></tr></table></figure>
<p>如果偷懒，可以使用<code>json.dumps(s, default=lambda obj: obj.__dict__)</code>，因为通常class的实例都有一个<strong>dict</strong>属性，它就是一个dict，用来存储实例变量。也有少数例外，比如定义了<strong>slots</strong>的class。<br>同理，反序列化，也可以使用这种方法，同时传参时，<code>object_hook</code>参数填写对应的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def dict2student(d):</span><br><span class="line">     return Student(d[&apos;name&apos;], d[&apos;age&apos;], d[&apos;score&apos;])</span><br><span class="line">json.loads(json_str, object_hook=dict2student)</span><br></pre></td></tr></table></figure>
<p>此外，在出现中文时，<code>ensure_ascii</code>参数可以确定中文是否需要转换为ASCii码。</p>
</li>
</ol>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>【注意】如果没有标明字符长度，只要从头开始完全匹配即可，后面是否匹配都算匹配。<code>re.match(&#39;abc\d&#39;,&#39;abc22345ad&#39;)</code>是匹配的。</p>
<ol>
<li><p>精确匹配</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\d          匹配数字</span><br><span class="line">\w          匹配一个字母、数字</span><br><span class="line">\s          匹配空格（也包括Tab等空白符）</span><br><span class="line">.           匹配任意字符</span><br><span class="line">\转义字符    匹配转义字符，如 - _</span><br></pre></td></tr></table></figure>
</li>
<li><p>变长字符</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 表示任意个字符（包括0个）</span><br><span class="line">+ 表示至少一个字符</span><br><span class="line">? 表示0个或1个字符</span><br><span class="line">&#123;n&#125; 表示n个字符，</span><br><span class="line">&#123;n,m&#125; 表示n-m个字符</span><br></pre></td></tr></table></figure>
</li>
<li><p>范围。可以用[]表示范围，比如：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0-9a-zA-Z\_]       可以匹配一个数字、字母或者下划线</span><br><span class="line">[0-9a-zA-Z\_]+      可以匹配至少由一个数字、字母或者下划线组成的字符串</span><br><span class="line">[a-zA-Z\_][0-9a-zA-Z\_]*    可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量</span><br><span class="line">[a-zA-Z\_][0-9a-zA-Z\_]&#123;0, 19&#125;  更精确地限制了变量的长度是1-20个字符</span><br></pre></td></tr></table></figure>
<p> <code>python|java</code>可以匹配python或java<br> <code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。<br> <code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</p>
</li>
<li>Python提供<code>re模块</code>，包含所有正则表达式的功能。<br>由于Python的字符串本身也用\转义，所以要特别注意，建议使用<code>r</code>前缀，这样就不需要考虑转义了。<br><code>match()</code>方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。如：<code>re.match(r&#39;^\d{3}\-\d{3,8}$&#39;, &#39;010-12345&#39;)</code><br><code>split()</code>用来切分字符串。 如<code>re.split(r&#39;[\s\,]+&#39;, &#39;a,b, c  d&#39;)</code><br><code>group()</code>用来提取分组，<code>group(0)</code>表示原始字符串，之后表示第n个子串。<code>groups()</code>表示分组后的元组。<code>re.match(r&#39;^(\d{3})-(\d{3,8})$&#39;, &#39;010-12345&#39;)  ==&gt; m.group(1)</code><br><code>compile()</code>用于预编译正则表达式，为了效率。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">re_telephone = re.compile(r&apos;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&apos;)</span><br><span class="line">re_telephone.match(&apos;010-12345&apos;).groups()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="内建模块"><a href="#内建模块" class="headerlink" title="内建模块"></a>内建模块</h3><h4 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a>datetime模块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime   #导入datetime类</span><br><span class="line"></span><br><span class="line">now = datetime.now()    #获取当前时间,返回类型是datetime</span><br><span class="line">dt  = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime</span><br><span class="line"></span><br><span class="line">dt.timestamp()  # 把datetime转换为timestamp，是一个浮点数，小数位表示毫秒数</span><br><span class="line">datetime.fromtimestamp(t) #把timestamp转换为本地时间的datetime</span><br><span class="line">datetime.utcfromtimestamp(t)  #把timestamp转换为UTC时间的datetime</span><br><span class="line"></span><br><span class="line">datetime.strptime(&apos;2015-6-1 18:19:59&apos;, &apos;%Y-%m-%d %H:%M:%S&apos;)   #把str转换为datetime</span><br><span class="line">datetime.now().strftime(&apos;%a, %b %d %H:%M&apos;)  #时间转换为str</span><br><span class="line"></span><br><span class="line">now + timedelta(days=2, hours=12)  #时间的加减</span><br><span class="line"></span><br><span class="line">now.replace(tzinfo=timezone(timedelta(hours=8))) # 强制设置为UTC+8:00</span><br><span class="line">utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)   #拿到UTC时间，并强制设置时区为UTC+0:00</span><br><span class="line">bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))  #astimezone()将转换时区为北京时间:</span><br></pre></td></tr></table></figure>
<p>注意：datetime表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。</p>
<h4 id="collections模块"><a href="#collections模块" class="headerlink" title="collections模块"></a>collections模块</h4><p>用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用。创建对象是tuple的一种子类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point = namedtuple(&apos;Point&apos;, [&apos;x&apos;, &apos;y&apos;])  #创建一个自定义的tuple对象并且规定了tuple元素的个数，</span><br><span class="line">p = Point(1, 2) #可以用属性而不是索引来引用tuple的某个元素 p.x</span><br></pre></td></tr></table></figure></p>
<p>用<code>deque</code>可以高效实现插入和删除操作的双向列表，适合用于队列和栈。支持append()、pop()、appendleft()、popleft()，可以非常高效地往头部添加或删除元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line">q = deque([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])</span><br><span class="line">q.append(&apos;x&apos;)</span><br><span class="line">q.appendleft(&apos;y&apos;)</span><br></pre></td></tr></table></figure></p>
<p>使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用<code>defaultdict</code>，其他行为与dict完全一样。注意默认值是调用函数返回的，而函数在创建defaultdict对象时传入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line">dd = defaultdict(lambda: &apos;N/A&apos;)</span><br></pre></td></tr></table></figure></p>
<p>使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。如果要保持Key按插入的顺序，可以用<code>OrderedDict</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">od = OrderedDict([(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 3)])</span><br><span class="line">list(od.keys()) # 按照插入的Key的顺序返回</span><br></pre></td></tr></table></figure></p>
<p><code>Counter</code>是一个简单的计数器，实际上也是dict的一个子类。例如，统计字符出现的个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line">    c = Counter()</span><br><span class="line">    for ch in &apos;programming&apos;:</span><br><span class="line">...     c[ch] = c[ch] + 1</span><br></pre></td></tr></table></figure></p>
<h4 id="base64模块"><a href="#base64模块" class="headerlink" title="base64模块"></a>base64模块</h4><p>Base64是一种用64个字符 {‘A’, ‘B’, ‘C’, … ‘a’, ‘b’, ‘c’, … ‘0’, ‘1’, … ‘+’, ‘/‘} 来表示任意二进制数据的方法。由于在URL中+和/不能直接作为参数，所以又有一种”url safe”的base64编码，其实就是把字符+和/分别变成-和_：<br>它的原理是：每3个字节一组，按照6bit划分为4组。如果编码不是3的倍数，就用<code>\x00</code>字节补足，并添加对应数量的<code>=</code>号。由于=字符也可能出现在Base64编码中，但=用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把=去掉.<br>Base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行。Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">base64.b64encode(b&apos;binary\x00string&apos;)</span><br><span class="line">base64.b64decode(b&apos;YmluYXJ5AHN0cmluZw==&apos;)</span><br><span class="line">base64.urlsafe_b64encode(b&apos;i\xb7\x1d\xfb\xef\xff&apos;)</span><br><span class="line">base64.urlsafe_b64decode(&apos;abcd--__&apos;)</span><br></pre></td></tr></table></figure></p>
<h4 id="struct模块"><a href="#struct模块" class="headerlink" title="struct模块"></a>struct模块</h4><p>解决bytes和其他二进制数据类型的转换。<a href="https://docs.python.org/3/library/struct.html#format-characters" target="_blank" rel="noopener">参数说明</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import struct</span><br><span class="line">struct.pack(&apos;&gt;I&apos;, 10240099)  #转换为二进制，&gt;表示字节顺序是big-endian，也就是网络序，I表示4字节无符号整数</span><br><span class="line">struct.unpack(&apos;&gt;IH&apos;, b&apos;\xf0\xf0\xf0\xf0\x80\x80&apos;)    #后面的bytes依次变为I：4字节无符号整数和H：2字节无符号整数</span><br></pre></td></tr></table></figure></p>
<h4 id="hashlib模块"><a href="#hashlib模块" class="headerlink" title="hashlib模块"></a>hashlib模块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">#MD5</span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line">md5.update(&apos;how to use md5 in &apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">md5.update(&apos;python hashlib?&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">print(md5.hexdigest())</span><br><span class="line"></span><br><span class="line">#SHA1</span><br><span class="line">sha1 = hashlib.sha1()</span><br><span class="line">sha1.update(&apos;how to use sha1 in &apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">sha1.update(&apos;python hashlib?&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">print(sha1.hexdigest())</span><br></pre></td></tr></table></figure>
<h4 id="hmac模块"><a href="#hmac模块" class="headerlink" title="hmac模块"></a>hmac模块</h4><p>Hmac算法通过一个标准算法，在计算哈希的过程中，把key混入计算过程中。要注意传入的key和message都是bytes类型，str类型需要首先编码为bytes<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import hmac</span><br><span class="line">message = b&apos;Hello, world!&apos;</span><br><span class="line">key = b&apos;secret&apos;</span><br><span class="line">h = hmac.new(key, message, digestmod=&apos;MD5&apos;)</span><br><span class="line"># 如果消息很长，可以多次调用h.update(msg)</span><br><span class="line">h.hexdigest()</span><br></pre></td></tr></table></figure></p>
<h4 id="itertools模块"><a href="#itertools模块" class="headerlink" title="itertools模块"></a>itertools模块</h4><p>itertools提供了非常有用的用于操作迭代对象的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">natuals = itertools.count(1,2)  #count()会创建一个无限的迭代器,从1开始，间隔为2</span><br><span class="line">cs = itertools.cycle(&apos;ABC&apos;)  #cycle()会把传入的一个序列无限重复下去</span><br><span class="line">ns = itertools.repeat(&apos;A&apos;, 3)  #repeat()负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数</span><br><span class="line"></span><br><span class="line">无限序列在for迭代时才会无限地迭代下去；但通过takewhile()等函数根据条件判断来截取出一个有限的序列</span><br><span class="line">ns = itertools.takewhile(lambda x: x &lt;= 10, natuals)</span><br><span class="line"></span><br><span class="line">itertools.chain(&apos;ABC&apos;, &apos;XYZ&apos;) #把一组迭代对象串联起来，形成一个更大的迭代器</span><br><span class="line">itertools.groupby(&apos;AaaBBbcCAAa&apos;, lambda c: c.upper())  #把迭代器中相邻的重复元素挑出来放在一起</span><br></pre></td></tr></table></figure></p>
<h4 id="contexlib模块"><a href="#contexlib模块" class="headerlink" title="contexlib模块"></a>contexlib模块</h4><p>任何对象，只要正确实现了上下文管理，就可以用于with语句。<br>实现上下文管理是通过<code>__enter__</code>和<code>__exit__</code>这两个方法实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#正常写法：</span><br><span class="line">class Query(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def __enter__(self):</span><br><span class="line">        print(&apos;Begin&apos;)</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __exit__(self, exc_type, exc_value, traceback):</span><br><span class="line">        if exc_type:</span><br><span class="line">            print(&apos;Error&apos;)</span><br><span class="line">        else:</span><br><span class="line">            print(&apos;End&apos;)</span><br><span class="line"></span><br><span class="line">    def query(self):</span><br><span class="line">        print(&apos;Query info about %s...&apos; % self.name)</span><br><span class="line"></span><br><span class="line">with Query(&apos;Bob&apos;) as q:</span><br><span class="line">    q.query()</span><br><span class="line"></span><br><span class="line">#使用装饰器</span><br><span class="line">from contextlib import contextmanager</span><br><span class="line"></span><br><span class="line">class Query(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def query(self):</span><br><span class="line">        print(&apos;Query info about %s...&apos; % self.name)</span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def create_query(name):</span><br><span class="line">    print(&apos;Begin&apos;)</span><br><span class="line">    q = Query(name)</span><br><span class="line">    yield q        #用yield语句把with ... as var把变量输出出去，然后，with语句就可以正常地工作了</span><br><span class="line">    print(&apos;End&apos;)</span><br><span class="line"></span><br><span class="line">with create_query(&apos;Bob&apos;) as q:</span><br><span class="line">    q.query()</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@contextmanager</span><br><span class="line">def tag(name):</span><br><span class="line">    print(&quot;&lt;%s&gt;&quot; % name)</span><br><span class="line">    yield</span><br><span class="line">    print(&quot;&lt;/%s&gt;&quot; % name)</span><br><span class="line"></span><br><span class="line">with tag(&quot;h1&quot;):</span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">    print(&quot;world&quot;)</span><br></pre></td></tr></table></figure>
<p>如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用closing()来把该对象变为上下文对象。<br>closing也是一个经过@contextmanager装饰的generator<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from contextlib import closing</span><br><span class="line">from urllib.request import urlopen</span><br><span class="line"></span><br><span class="line">with closing(urlopen(&apos;https://www.python.org&apos;)) as page:</span><br><span class="line">    for line in page:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure></p>
<h4 id="urllib模块"><a href="#urllib模块" class="headerlink" title="urllib模块"></a>urllib模块</h4><p>urllib的request模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP的响应<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line">with request.urlopen(&apos;http://madj.xin&apos;) as f:</span><br><span class="line">    data = f.read()</span><br><span class="line">    print(&apos;Status:&apos;, f.status, f.reason)</span><br><span class="line">    for k, v in f.getheaders():</span><br><span class="line">        print(&apos;%s: %s&apos; % (k, v))</span><br><span class="line">    print(&apos;Data:&apos;, data.decode(&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure></p>
<p>如果我们要想模拟浏览器发送GET请求，就需要使用Request对象，通过往Request对象添加HTTP头，我们就可以把请求伪装成浏览器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">req = request.Request(&apos;http://www.douban.com/&apos;)</span><br><span class="line">req.add_header(&apos;User-Agent&apos;, &apos;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&apos;)</span><br><span class="line">with request.urlopen(req) as f:</span><br><span class="line">    print(&apos;Status:&apos;, f.status, f.reason)</span><br><span class="line">    for k, v in f.getheaders():</span><br><span class="line">        print(&apos;%s: %s&apos; % (k, v))</span><br><span class="line">    print(&apos;Data:&apos;, f.read().decode(&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure></p>
<p>如果要以POST发送一个请求，只需要把参数data以bytes形式传入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">login_data = parse.urlencode([</span><br><span class="line">    (&apos;username&apos;, email),</span><br><span class="line">    (&apos;password&apos;, passwd),</span><br><span class="line">    (&apos;entry&apos;, &apos;mweibo&apos;),</span><br><span class="line">    (&apos;client_id&apos;, &apos;&apos;),</span><br><span class="line">    (&apos;savestate&apos;, &apos;1&apos;),</span><br><span class="line">    (&apos;ec&apos;, &apos;&apos;),</span><br><span class="line">    (&apos;pagerefer&apos;, &apos;https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F&apos;)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">with request.urlopen(req, data=login_data.encode(&apos;utf-8&apos;)) as f:</span><br><span class="line">    .......</span><br></pre></td></tr></table></figure></p>
<p>如果还需要更复杂的控制，比如通过一个Proxy去访问网站，我们需要利用ProxyHandler来处理，示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proxy_handler = urllib.request.ProxyHandler(&#123;&apos;http&apos;: &apos;http://www.example.com:3128/&apos;&#125;)</span><br><span class="line">proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()</span><br><span class="line">proxy_auth_handler.add_password(&apos;realm&apos;, &apos;host&apos;, &apos;username&apos;, &apos;password&apos;)</span><br><span class="line">opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)</span><br><span class="line">with opener.open(&apos;http://www.example.com/login.html&apos;) as f:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p>
<h4 id="XML模块"><a href="#XML模块" class="headerlink" title="XML模块"></a>XML模块</h4><p>操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。<br>正常情况下，优先考虑SAX，因为DOM实在太占内存。<br>在Python中使用SAX解析XML非常简洁，通常我们关心的事件是<code>start_element</code>，<code>end_element</code>和<code>char_data</code>，准备好这3个函数，然后就可以解析xml了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from xml.parsers.expat import ParserCreate</span><br><span class="line"></span><br><span class="line">class DefaultSaxHandler(object):</span><br><span class="line">    def start_element(self, name, attrs):</span><br><span class="line">        print(&apos;sax:start_element: %s, attrs: %s&apos; % (name, str(attrs)))</span><br><span class="line"></span><br><span class="line">    def end_element(self, name):</span><br><span class="line">        print(&apos;sax:end_element: %s&apos; % name)</span><br><span class="line"></span><br><span class="line">    def char_data(self, text):</span><br><span class="line">        print(&apos;sax:char_data: %s&apos; % text)</span><br><span class="line"></span><br><span class="line">xml = r&apos;&apos;&apos;&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;/python&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;/ruby&quot;&gt;Ruby&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">handler = DefaultSaxHandler()</span><br><span class="line">parser = ParserCreate()</span><br><span class="line">parser.StartElementHandler = handler.start_element</span><br><span class="line">parser.EndElementHandler = handler.end_element</span><br><span class="line">parser.CharacterDataHandler = handler.char_data</span><br><span class="line">parser.Parse(xml)</span><br></pre></td></tr></table></figure></p>
<p>最有效的生成XML的方法是拼接字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line">L.append(r&apos;&lt;?xml version=&quot;1.0&quot;?&gt;&apos;)</span><br><span class="line">L.append(r&apos;&lt;root&gt;&apos;)</span><br><span class="line">L.append(encode(&apos;some &amp; data&apos;))</span><br><span class="line">L.append(r&apos;&lt;/root&gt;&apos;)</span><br><span class="line">return &apos;&apos;.join(L)</span><br></pre></td></tr></table></figure></p>
<h4 id="HTMLParser模块"><a href="#HTMLParser模块" class="headerlink" title="HTMLParser模块"></a>HTMLParser模块</h4><p>HTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from html.parser import HTMLParser</span><br><span class="line">from html.entities import name2codepoint</span><br><span class="line"></span><br><span class="line">class MyHTMLParser(HTMLParser):</span><br><span class="line"></span><br><span class="line">    def handle_starttag(self, tag, attrs):</span><br><span class="line">        print(&apos;&lt;%s&gt;&apos; % tag)</span><br><span class="line"></span><br><span class="line">    def handle_endtag(self, tag):</span><br><span class="line">        print(&apos;&lt;/%s&gt;&apos; % tag)</span><br><span class="line"></span><br><span class="line">    def handle_startendtag(self, tag, attrs):</span><br><span class="line">        print(&apos;&lt;%s/&gt;&apos; % tag)</span><br><span class="line"></span><br><span class="line">    def handle_data(self, data):</span><br><span class="line">        print(data)</span><br><span class="line"></span><br><span class="line">    def handle_comment(self, data):</span><br><span class="line">        print(&apos;&lt;!--&apos;, data, &apos;--&gt;&apos;)</span><br><span class="line"></span><br><span class="line">    def handle_entityref(self, name):</span><br><span class="line">        print(&apos;&amp;%s;&apos; % name)</span><br><span class="line"></span><br><span class="line">    def handle_charref(self, name):</span><br><span class="line">        print(&apos;&amp;#%s;&apos; % name)</span><br><span class="line"></span><br><span class="line">parser = MyHTMLParser()</span><br><span class="line">parser.feed(&apos;&apos;&apos;&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- test html parser --&gt;</span><br><span class="line">    &lt;p&gt;Some &lt;a href=\&quot;#\&quot;&gt;html&lt;/a&gt; HTML&amp;nbsp;tutorial...&lt;br&gt;END&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;&apos;&apos;&apos;)</span><br></pre></td></tr></table></figure></p>
<p>feed()方法可以多次调用，也就是不一定一次把整个HTML字符串都塞进去，可以一部分一部分塞进去。特殊字符有两种，一种是英文表示的&nbsp;，一种是数字表示的&#1234;，这两种字符都可以通过Parser解析出来。</p>
<h3 id="常用第三方模块"><a href="#常用第三方模块" class="headerlink" title="常用第三方模块"></a>常用第三方模块</h3><h4 id="Pillow模块"><a href="#Pillow模块" class="headerlink" title="Pillow模块"></a>Pillow模块</h4><p>图像处理库。<br>缩放图像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line"># 打开一个jpg图像文件，注意是当前路径:</span><br><span class="line">im = Image.open(&apos;test.jpg&apos;)</span><br><span class="line"># 获得图像尺寸:</span><br><span class="line">w, h = im.size</span><br><span class="line">print(&apos;Original image size: %sx%s&apos; % (w, h))</span><br><span class="line"># 缩放到50%:</span><br><span class="line">im.thumbnail((w//2, h//2))</span><br><span class="line">print(&apos;Resize image to: %sx%s&apos; % (w//2, h//2))</span><br><span class="line"># 把缩放后的图像用jpeg格式保存:</span><br><span class="line">im.save(&apos;thumbnail.jpg&apos;, &apos;jpeg&apos;)</span><br></pre></td></tr></table></figure></p>
<p>模糊图像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image, ImageFilter</span><br><span class="line"></span><br><span class="line"># 打开一个jpg图像文件，注意是当前路径:</span><br><span class="line">im = Image.open(&apos;test.jpg&apos;)</span><br><span class="line"># 应用模糊滤镜:</span><br><span class="line">im2 = im.filter(ImageFilter.BLUR)</span><br><span class="line">im2.save(&apos;blur.jpg&apos;, &apos;jpeg&apos;)</span><br></pre></td></tr></table></figure></p>
<p>绘制验证码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image, ImageDraw, ImageFont, ImageFilter</span><br><span class="line"></span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line"># 随机字母:</span><br><span class="line">def rndChar():</span><br><span class="line">    return chr(random.randint(65, 90))</span><br><span class="line"></span><br><span class="line"># 随机颜色1:</span><br><span class="line">def rndColor():</span><br><span class="line">    return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))</span><br><span class="line"></span><br><span class="line"># 随机颜色2:</span><br><span class="line">def rndColor2():</span><br><span class="line">    return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))</span><br><span class="line"></span><br><span class="line"># 240 x 60:</span><br><span class="line">width = 60 * 4</span><br><span class="line">height = 60</span><br><span class="line">image = Image.new(&apos;RGB&apos;, (width, height), (255, 255, 255))</span><br><span class="line"># 创建Font对象:</span><br><span class="line">font = ImageFont.truetype(&apos;/Library/Fonts/Arial.ttf&apos;, 36)</span><br><span class="line"># 创建Draw对象:</span><br><span class="line">draw = ImageDraw.Draw(image)</span><br><span class="line"># 填充每个像素:</span><br><span class="line">for x in range(width):</span><br><span class="line">    for y in range(height):</span><br><span class="line">        draw.point((x, y), fill=rndColor())</span><br><span class="line"># 输出文字:</span><br><span class="line">for t in range(4):</span><br><span class="line">    draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2())</span><br><span class="line"># 模糊:</span><br><span class="line">image = image.filter(ImageFilter.BLUR)</span><br><span class="line">image.save(&apos;code.jpg&apos;, &apos;jpeg&apos;)</span><br></pre></td></tr></table></figure></p>
<h3 id="多进程和线程"><a href="#多进程和线程" class="headerlink" title="多进程和线程"></a>多进程和线程</h3><ol>
<li><p>Unix/Linux下，<code>os.fork()</code>调用一次，然后，分别在父进程和子进程内返回。<br>此外，multiprocessing模块提供了一个Process类来代表一个进程对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 子进程要执行的代码</span><br><span class="line">def run_proc(name):</span><br><span class="line">    print(&apos;Run child process %s (%s)...&apos; % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    print(&apos;Parent process %s.&apos; % os.getpid())</span><br><span class="line">    p = Process(target=run_proc, args=(&apos;test&apos;,))</span><br><span class="line">    print(&apos;Child process will start.&apos;)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()  #join()方法可以等待子进程结束后再继续往下运行</span><br><span class="line">    print(&apos;Child process end.&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool</span><br><span class="line">import os, time, random</span><br><span class="line"></span><br><span class="line">def long_time_task(name):</span><br><span class="line">    print(&apos;Run task %s (%s)...&apos; % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * 3)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&apos;Task %s runs %0.2f seconds.&apos; % (name, (end - start)))</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    print(&apos;Parent process %s.&apos; % os.getpid())</span><br><span class="line">    p = Pool(4)</span><br><span class="line">    for i in range(5):</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    print(&apos;Waiting for all subprocesses done...&apos;)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print(&apos;All subprocesses done.&apos;)</span><br></pre></td></tr></table></figure>
<p>对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。请注意输出的结果，task 0，1，2，3是立刻执行的，而task 4要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成：<code>p = Pool(5)</code>就可以同时跑5个进程。</p>
</li>
<li>调用外部进程，可以使用<code>subprocess</code>模块。<code>subprocess.call([&#39;nslookup&#39;,&#39;www.python.org&#39;])</code>，如果子进程还需要输入，则可以通过communicate()方法输入。</li>
<li>Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。</li>
<li><p>使用threading模块使用线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = threading.Thread(target=loop, name=&apos;LoopThread&apos;)</span><br><span class="line"> t.start()</span><br><span class="line"> t.join()</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用同步锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">balance = 0</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def run_thread(n):</span><br><span class="line">    for i in range(100000):</span><br><span class="line">        # 先要获取锁:</span><br><span class="line">        lock.acquire()</span><br><span class="line">        try:</span><br><span class="line">            # 放心地改吧:</span><br><span class="line">            change_it(n)</span><br><span class="line">        finally:</span><br><span class="line">            # 改完了一定要释放锁:</span><br><span class="line">            lock.release()</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line"># 创建全局ThreadLocal对象:</span><br><span class="line">local_school = threading.local()</span><br><span class="line"></span><br><span class="line">def process_student():</span><br><span class="line">    # 获取当前线程关联的student:</span><br><span class="line">    std = local_school.student</span><br><span class="line">    print(&apos;Hello, %s (in %s)&apos; % (std, threading.current_thread().name))</span><br><span class="line"></span><br><span class="line">def process_thread(name):</span><br><span class="line">    # 绑定ThreadLocal的student:</span><br><span class="line">    local_school.student = name</span><br><span class="line">    process_student()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target= process_thread, args=(&apos;Alice&apos;,), name=&apos;Thread-A&apos;)</span><br><span class="line">t2 = threading.Thread(target= process_thread, args=(&apos;Bob&apos;,), name=&apos;Thread-B&apos;)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python/" rel="tag"># python</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/24/15-CountFile/" rel="next" title="使用python统计提交文件并生成报表">
                <i class="fa fa-chevron-left"></i> 使用python统计提交文件并生成报表
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/05/17-hadoop-NativeCodeLoader/" rel="prev" title="Hadoop异常解决(util.NativeCodeLoader)">
                Hadoop异常解决(util.NativeCodeLoader) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jerry</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语句"><span class="nav-number">2.</span> <span class="nav-text">语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">3.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块"><span class="nav-number">4.</span> <span class="nav-text">模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象编程"><span class="nav-number">5.</span> <span class="nav-text">面向对象编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误、调试、测试"><span class="nav-number">6.</span> <span class="nav-text">错误、调试、测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO处理"><span class="nav-number">7.</span> <span class="nav-text">IO处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正则表达式"><span class="nav-number">8.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内建模块"><span class="nav-number">9.</span> <span class="nav-text">内建模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#datetime模块"><span class="nav-number">9.1.</span> <span class="nav-text">datetime模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collections模块"><span class="nav-number">9.2.</span> <span class="nav-text">collections模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#base64模块"><span class="nav-number">9.3.</span> <span class="nav-text">base64模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#struct模块"><span class="nav-number">9.4.</span> <span class="nav-text">struct模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashlib模块"><span class="nav-number">9.5.</span> <span class="nav-text">hashlib模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hmac模块"><span class="nav-number">9.6.</span> <span class="nav-text">hmac模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#itertools模块"><span class="nav-number">9.7.</span> <span class="nav-text">itertools模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#contexlib模块"><span class="nav-number">9.8.</span> <span class="nav-text">contexlib模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#urllib模块"><span class="nav-number">9.9.</span> <span class="nav-text">urllib模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XML模块"><span class="nav-number">9.10.</span> <span class="nav-text">XML模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTMLParser模块"><span class="nav-number">9.11.</span> <span class="nav-text">HTMLParser模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用第三方模块"><span class="nav-number">10.</span> <span class="nav-text">常用第三方模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Pillow模块"><span class="nav-number">10.1.</span> <span class="nav-text">Pillow模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多进程和线程"><span class="nav-number">11.</span> <span class="nav-text">多进程和线程</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jerry</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">39.3k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info"><a class="theme-link" target="_blank" href="http://www.miitbeian.gov.cn/">浙ICP备17055283号
</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


</body>
</html>
